"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPrompt = exports.usePagination = exports.useRef = exports.useKeypress = exports.useEffect = exports.useState = exports.usePrefix = void 0;
const readline = __importStar(require("node:readline"));
const type_1 = require("@inquirer/type");
const chalk_1 = __importDefault(require("chalk"));
const cli_width_1 = __importDefault(require("cli-width"));
const mute_stream_1 = __importDefault(require("mute-stream"));
const screen_manager_mjs_1 = __importDefault(require('./lib/screen-manager.js'));
const options_mjs_1 = require('./lib/options.js');
const utils_mjs_1 = require('./lib/utils.js');
var prefix_mjs_1 = require('./lib/prefix.js');
Object.defineProperty(exports, "usePrefix", { enumerable: true, get: function () { return prefix_mjs_1.usePrefix; } });
__exportStar(require('./lib/key.js'), exports);
__exportStar(require('./lib/Separator.js'), exports);
const hooks = [];
const hooksCleanup = [];
const hooksEffect = [];
let index = 0;
let handleChange = () => { };
let sessionRl;
function resetHookState() {
    hooks.length = 0;
    hooksCleanup.length = 0;
    hooksEffect.length = 0;
    index = 0;
    handleChange = () => { };
    sessionRl = undefined;
}
function cleanupHook(index) {
    const cleanFn = hooksCleanup[index];
    if (typeof cleanFn === 'function') {
        cleanFn();
    }
}
function mergeStateUpdates(fn) {
    const wrapped = (...args) => {
        let shouldUpdate = false;
        const oldHandleChange = handleChange;
        handleChange = () => {
            shouldUpdate = true;
        };
        const returnValue = fn(...args);
        if (shouldUpdate) {
            oldHandleChange();
        }
        handleChange = oldHandleChange;
        return returnValue;
    };
    return wrapped;
}
function useState(defaultValue) {
    const _idx = index;
    index++;
    if (!(_idx in hooks)) {
        if (typeof defaultValue === 'function') {
            hooks[_idx] = defaultValue();
        }
        else {
            hooks[_idx] = defaultValue;
        }
    }
    return [
        hooks[_idx],
        (newValue) => {
            // Noop if the value is still the same.
            if (hooks[_idx] !== newValue) {
                hooks[_idx] = newValue;
                // Trigger re-render
                handleChange();
            }
        },
    ];
}
exports.useState = useState;
function useEffect(cb, depArray) {
    const rl = sessionRl;
    if (!rl) {
        throw new Error('useEffect must be used within a prompt');
    }
    const _idx = index;
    index++;
    const oldDeps = hooks[_idx];
    let hasChanged = true;
    if (oldDeps) {
        hasChanged = depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    }
    if (hasChanged) {
        hooksEffect.push(mergeStateUpdates(() => {
            cleanupHook(_idx);
            const cleanFn = cb(rl);
            if (cleanFn != null && typeof cleanFn !== 'function') {
                throw new Error('useEffect return value must be a cleanup function or nothing.');
            }
            hooksCleanup[_idx] = cleanFn;
        }));
    }
    hooks[_idx] = depArray;
}
exports.useEffect = useEffect;
function useKeypress(userHandler) {
    const rl = sessionRl;
    if (!rl) {
        throw new Error('useKeypress must be used within a prompt');
    }
    useEffect(() => {
        const handler = mergeStateUpdates((_input, event) => {
            userHandler(event, rl);
        });
        rl.input.on('keypress', handler);
        return () => {
            rl.input.removeListener('keypress', handler);
        };
    }, [userHandler]);
}
exports.useKeypress = useKeypress;
function useRef(val) {
    return useState({ current: val })[0];
}
exports.useRef = useRef;
function usePagination(output, { active, pageSize = 7, }) {
    const state = useRef({
        pointer: 0,
        lastIndex: 0,
    });
    const rl = sessionRl;
    if (!rl) {
        throw new Error('usePagination must be used within a prompt');
    }
    const width = (0, cli_width_1.default)({ defaultWidth: 80, output: rl.output });
    const lines = (0, utils_mjs_1.breakLines)(output, width).split('\n');
    // Make sure there's enough lines to paginate
    if (lines.length <= pageSize) {
        return output;
    }
    const middleOfList = Math.floor(pageSize / 2);
    // Move the pointer only when the user go down and limit it to the middle of the list
    const { pointer: prevPointer, lastIndex } = state.current;
    if (prevPointer < middleOfList && lastIndex < active && active - lastIndex < pageSize) {
        state.current.pointer = Math.min(middleOfList, prevPointer + active - lastIndex);
    }
    state.current.lastIndex = active;
    // Duplicate the lines so it give an infinite list look
    const infinite = [lines, lines, lines].flat();
    const topIndex = Math.max(0, active + lines.length - state.current.pointer);
    const section = infinite.splice(topIndex, pageSize).join('\n');
    return section + '\n' + chalk_1.default.dim('(Move up and down to reveal more choices)');
}
exports.usePagination = usePagination;
function createPrompt(view) {
    const prompt = (config, context) => {
        var _a, _b;
        if (sessionRl) {
            throw new Error('An inquirer prompt is already running.\nMake sure you await the result of the previous prompt before calling another prompt.');
        }
        // Default `input` to stdin
        const input = (_a = context === null || context === void 0 ? void 0 : context.input) !== null && _a !== void 0 ? _a : process.stdin;
        // Add mute capabilities to the output
        const output = new mute_stream_1.default();
        output.pipe((_b = context === null || context === void 0 ? void 0 : context.output) !== null && _b !== void 0 ? _b : process.stdout);
        sessionRl = readline.createInterface({
            terminal: true,
            input,
            output,
        });
        const screen = new screen_manager_mjs_1.default(sessionRl);
        let cancel = () => { };
        const answer = new type_1.CancelablePromise((resolve, reject) => {
            const checkCursorPos = () => {
                screen.checkCursorPos();
            };
            const onExit = () => {
                try {
                    let len = hooksCleanup.length;
                    while (len--) {
                        cleanupHook(len);
                    }
                }
                catch (err) {
                    reject(err);
                }
                if (context === null || context === void 0 ? void 0 : context.clearPromptOnDone) {
                    screen.clean();
                }
                else {
                    screen.clearContent();
                }
                screen.done();
                process.removeListener('SIGINT', onForceExit);
                sessionRl === null || sessionRl === void 0 ? void 0 : sessionRl.input.removeListener('keypress', checkCursorPos);
                resetHookState();
            };
            cancel = () => {
                onExit();
                reject(new Error('Prompt was canceled'));
            };
            let shouldHandleExit = true;
            const onForceExit = () => {
                if (shouldHandleExit) {
                    shouldHandleExit = false;
                    onExit();
                    reject(new Error('User force closed the prompt with CTRL+C'));
                }
            };
            // Handle cleanup on force exit. Main reason is so we restore the cursor if a prompt hide it.
            process.on('SIGINT', onForceExit);
            const done = (value) => {
                // Delay execution to let time to the hookCleanup functions to registers.
                setImmediate(() => {
                    onExit();
                    // Finally we resolve our promise
                    resolve(value);
                });
            };
            const workLoop = (resolvedConfig) => {
                index = 0;
                hooksEffect.length = 0;
                handleChange = () => workLoop(resolvedConfig);
                try {
                    const nextView = view(resolvedConfig, done);
                    for (const effect of hooksEffect) {
                        effect();
                    }
                    const [content, bottomContent] = typeof nextView === 'string' ? [nextView] : nextView;
                    screen.render(content, bottomContent);
                }
                catch (err) {
                    onExit();
                    reject(err);
                }
            };
            // TODO: we should display a loader while we get the default options.
            (0, options_mjs_1.getPromptConfig)(config).then((resolvedConfig) => {
                workLoop(resolvedConfig);
                // Re-renders only happen when the state change; but the readline cursor could change position
                // and that also requires a re-render (and a manual one because we mute the streams).
                // We set the listener after the initial workLoop to avoid a double render if render triggered
                // by a state change sets the cursor to the right position.
                sessionRl === null || sessionRl === void 0 ? void 0 : sessionRl.input.on('keypress', checkCursorPos);
            }, reject);
        });
        answer.catch(() => {
            resetHookState();
        });
        answer.cancel = cancel;
        return answer;
    };
    return prompt;
}
exports.createPrompt = createPrompt;
